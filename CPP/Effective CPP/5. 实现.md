
- [x] 5. 实现
	- [x] 条款26：尽可能延后变量定义式的出现时间
	- [x] 条款27：尽量少做转型动作
	- [x] 条款28：避免返回handles指向对象内部成分
	- [x] 条款29：为“异常安全”而努力是值得的
	- [x] 条款30：透彻了解inlining的里里外外
	- [x] 条款31：将文件间的编译依存关系降至最低

<br/><br/>
## 条款26：尽可能延后变量定义式的出现时间

考虑这种情况：

```c
void f()
{
    string a;
    other(); //可能会出现异常
    用到a
}
```

如果other函数出现异常，我们没有使用a，但是却要承担a构造和析构的成本。

此时应尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。  



再看一段代码：

```c
// 方法A：定义在循环外
Widget w;
for (int i = 0; i < n; ++i)
{
    w = 取决于i;
    ...
}

// 方法B：循环内
for (int i =0; i < n; ++i)
{
    Widget(取决于i);
}
```

方法A：1个构造函数 + 1个析构函数 + n个赋值操作

方法B：n个构造函数 + n个析构函数

如果赋值成本低于一组构造+析构，方法A大体比较高效。同时因为方法A造成w的作用域比方法B中的w更大，可能会对程序的可理解性和可维护性造成影响。



<br/><br/>

## 条款27：尽量少做转型动作

- static_cast：在编译时会进行类型检查，不执行运行时类型检查（转换安全性不如 dynamic_cast）
- const_cast：用于删除对象的 const 属性
- reinterpret_cast：允许将任何指针转换为任何其他指针类型
- dynamic_cast：



<br/><br/>
## 条款28：避免返回handles指向对象内部成分

避免返回handles（包括引用、指针、迭代器）指向对象内部

- 增加封装性
- 帮助const成员函数的行为像个const（因为一个const的函数缺返回了指向内部内向的handle，通过这个handle你可以修改内部对象）
- 将发生“虚吊号码牌”（dangling handles) 的风险降到最低（因为handle可能会比其所指对象更“长寿”）



<br/><br/>
## 条款29：为“异常安全”而努力是值得的



<br/><br/>

## 条款30：透彻了解inlining的里里外外



<br/><br/>

## 条款31：将文件间的编译依存关系降至最低